#  Copyright (C) 2017 Andreas FÃ¼glistaler <andreas.fueglistaler@gmail.com>
# 
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, you can obtain one at http://mozilla.org/MPL/2.0/.

################################################################################
# 2D Interpolation
################################################################################

function Interpolation{T}(xs::Union{Array{T, 1}, StepRangeLen{T}}, 
                                ys::Union{Array{T, 1}, StepRangeLen{T}}, 
                                fs::Array{T, 2}, fs_x::Array{T, 2}, 
                                fs_y::Array{T, 2}, fs_xy::Array{T, 2}, 
                                b::Boundary=undef)
    x0  = (xs[1], ys[1])
    dx  = (xs[2] - xs[1], ys[2] - ys[1])
    sz  = size(fs)
    ks  = Array{NTuple{16, T}}(sz[1] - 1, sz[2] - 1)
    for i = 1:sz[1] - 1
        for j = 1:sz[2] - 1
            ks[i, j] = cellcoeffs(fs[i:i+1, j:j+1], 
                                  fs_x[i:i+1, j:j+1]*dx[1],
                                  fs_y[i:i+1, j:j+1]*dx[2], 
                                  fs_xy[i:i+1, j:j+1]*dx[1]*dx[2])
        end
    end
    Interpolation{T, b, 2, 16}(x0, dx, ks)
end   

function Interpolation{T}(xs::Union{Array{T, 1}, StepRangeLen{T}}, 
                                ys::Union{Array{T, 1}, StepRangeLen{T}}, 
                                f::Function, f_x::Function,
                                f_y::Function, f_xy::Function, 
                                b::Boundary=undef)

    Interpolation(xs, ys, f.(xs, ys'), f_x.(xs, ys'), f_y.(xs, ys'),
                    f_xy.(xs, ys'), b)
end

function interpolate{T}(f::Function, ip::Interpolation{T, unsafe}, x::T, y::T)
    #using varargs leads to performance issues
    xp, i = xp_i(x, ip.x0[1], ip.dx[1])
    yp, j = xp_i(y, ip.x0[2], ip.dx[2])

    @inbounds return f(ip.ks[i, j], xp, yp)
end


function interpolate{T}(f::Function, ip::Interpolation{T, throw_error}, 
                        x::T, y::T)
    xp, i = xp_i(x, ip.x0[1], ip.dx[1])
    yp, j = xp_i(y, ip.x0[2], ip.dx[2])

    return f(ip.ks[i, j], xp, yp)
end


function interpolate{T}(f::Function, ip::Interpolation{T, undef}, x::T, y::T)
    xp, i = xp_i(x, ip.x0[1], ip.dx[1])
    yp, j = xp_i(y, ip.x0[2], ip.dx[2])

    if checkbounds(Bool, ip.ks, i, j)
        @inbounds return f(ip.ks[i, j], xp, yp)
    else
        return nan(xp)
    end
end

interpolate(ip, x, y) = interpolate(poly, ip, x, y)

function diff(ip, x, y, edx, edy)
    poly_diff(ks, x, y) = poly(ks, x, y, dxdy{edx, edy}())
    return interpolate(poly_diff, ip, x, y)/ip.dx[1]^edx/ip.dx[2]^edy
end

diff_x(ip, x, y)      = diff(ip, x, y, 1, 0)
diff_y(ip, x, y)      = diff(ip, x, y, 0, 1)

################################################################################
#Private functions
################################################################################

xterms  = [
    :(xt0=1; xt1=x; xt2=x*x; xt3=xt2*x),
    :(xt0=0; xt1=1; xt2=2*x; xt3=3*x*x),
    :(xt0=0; xt1=0; xt2=2;   xt3=6x),
    :(xt0=0; xt1=0; xt2=0;   xt3=6)
]

yterms  = [
    :(yt0=1; yt1=y; yt2=y*y; yt3=yt2*y),
    :(yt0=0; yt1=1; yt2=2*y; yt3=3*y*y),
    :(yt0=0; yt1=0; yt2=2;   yt3=6y),
    :(yt0=0; yt1=0; yt2=0;   yt3=6)
]



type dxdy{M, N}
end

@generated function poly{T<:Number, M, N}(ks::NTuple{16 , T}, x::T, y::T, 
           trait::dxdy{M, N}=dxdy{0, 0}())
    xt  = xterms[M+1]
    yt  = yterms[N+1]

    e   = :0
    for i = 0:3
        xi  = parse("xt$i")
        for j = 0:3
            yj  = parse("yt$j")
            e   = :($xi*$yj*ks[$i*4 + $j + 1] + $e)
        end
    end
    return :($xt; $yt; $e)
end

#coefficients for one cell
function cellcoeffs{T<:Number}(fs::Array{T, 2}, fs_x::Array{T, 2},
                    fs_y::Array{T, 2}, fs_xy::Array{T, 2})
    #code generated by maple
    t1 = 2*fs_y[1, 1]
    t2 = 3*fs[1, 1]
    t5 = 2*fs[1, 1]
    t8 = 2*fs_xy[1, 1]
    t9 = 3*fs_x[1, 1]
    t10 = 3*fs_x[1, 2]
    t12 = 2*fs_x[1, 1]
    t13 = 2*fs_x[1, 2]
    t17 = 3*fs_y[1, 1]
    t18 = 3*fs_y[2, 1]
    t23 = 3*fs_x[2, 1]
    t24 = 3*fs_x[2, 2]
    t26 = 2*fs_xy[1, 2]
    t27 = 2*fs_xy[2, 1]
    t29 = 3*fs_y[1, 2]
    t31 = 3*fs_y[2, 2]
    t35 = 9*fs[2, 2] + 6*fs_x[1, 1] - 6*fs_x[1, 2] + t23 - t24 + 4*fs_xy[1, 1] + t26 + t27 + fs_xy[2, 2] + 6*fs_y[1, 1] + t29 - 6*fs_y[2, 1] - t31 + 9*fs[1, 1] - 9*fs[1, 2] - 9*fs[2, 1]
    t38 = 6*fs[1, 1]
    t39 = 6*fs[1, 2]
    t40 = 6*fs[2, 1]
    t41 = 6*fs[2, 2]
    t42 = 2*fs_x[2, 2]
    t43 = 2*fs_x[2, 1]
    t44 = -t8 - 4*fs_x[1, 1] + 4*fs_x[1, 2] - t38 + t39 + t40 - t17 + t18 - t41 - fs_xy[2, 1] + t42 - t43 + t31 - t26 - t29 - fs_xy[2, 2]
    t47 = 2*fs_y[2, 1]
    t51 = 2*fs_y[2, 2]
    t52 = 2*fs_y[1, 2]
    t53 = -4*fs_y[1, 1] - t8 + 4*fs_y[2, 1] - t38 + t39 - t9 + t10 + t40 - t41 - t27 + t24 - t23 + t51 - fs_xy[1, 2] - t52 - fs_xy[2, 2]
    t58 = 4*fs[1, 1] - 4*fs[1, 2] + t12 + fs_xy[1, 1] - t13 - 4*fs[2, 1] + t1 - t47 + 4*fs[2, 2] + fs_xy[2, 1] - t42 + t43 - t51 + fs_xy[1, 2] + t52 + fs_xy[2, 2]

    return (
        fs[1, 1],
        fs_y[1, 1],
        -t1 - t2 + 3*fs[1, 2] - fs_y[1, 2],
        t5 + fs_y[1, 1] - 2*fs[1, 2] + fs_y[1, 2],
        fs_x[1, 1],
        fs_xy[1, 1],
        -t8 - t9 + t10 - fs_xy[1, 2],
        t12 + fs_xy[1, 1] - t13 + fs_xy[1, 2],
        -t12 - t2 + 3*fs[2, 1] - fs_x[2, 1],
        -t8 - t17 + t18 - fs_xy[2, 1],
        t35,
        t44,
        t5 + fs_x[1, 1] - 2*fs[2, 1] + fs_x[2, 1],
        t1 + fs_xy[1, 1] - t47 + fs_xy[2, 1],
        t53,
        t58
    )
end

